["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/async/workqueue.js"],"~:js","goog.loadModule(function(exports) {\n  \"use strict\";\n  goog.module(\"goog.async.WorkQueue\");\n  goog.module.declareLegacyNamespace();\n  var FreeList = goog.require(\"goog.async.FreeList\");\n  var $jscomp$destructuring$var31 = goog.require(\"goog.asserts\");\n  var assert = $jscomp$destructuring$var31.assert;\n  var WorkQueue = function() {\n    this.workHead_ = null;\n    this.workTail_ = null;\n  };\n  WorkQueue.prototype.add = function(fn, scope) {\n    var item = this.getUnusedItem_();\n    item.set(fn, scope);\n    if (this.workTail_) {\n      this.workTail_.next = item;\n      this.workTail_ = item;\n    } else {\n      assert(!this.workHead_);\n      this.workHead_ = item;\n      this.workTail_ = item;\n    }\n  };\n  WorkQueue.prototype.remove = function() {\n    var item = null;\n    if (this.workHead_) {\n      item = this.workHead_;\n      this.workHead_ = this.workHead_.next;\n      if (!this.workHead_) {\n        this.workTail_ = null;\n      }\n      item.next = null;\n    }\n    return item;\n  };\n  WorkQueue.prototype.returnUnused = function(item) {\n    WorkQueue.freelist_.put(item);\n  };\n  WorkQueue.prototype.getUnusedItem_ = function() {\n    return WorkQueue.freelist_.get();\n  };\n  WorkQueue.DEFAULT_MAX_UNUSED = goog.define(\"goog.async.WorkQueue.DEFAULT_MAX_UNUSED\", 100);\n  WorkQueue.freelist_ = new FreeList(function() {\n    return new WorkItem();\n  }, function(item) {\n    return item.reset();\n  }, WorkQueue.DEFAULT_MAX_UNUSED);\n  var WorkItem = function() {\n    this.fn = null;\n    this.scope = null;\n    this.next = null;\n  };\n  WorkItem.prototype.set = function(fn, scope) {\n    this.fn = fn;\n    this.scope = scope;\n    this.next = null;\n  };\n  WorkItem.prototype.reset = function() {\n    this.fn = null;\n    this.scope = null;\n    this.next = null;\n  };\n  exports = WorkQueue;\n  return exports;\n});\n","~:source","/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\ngoog.module('goog.async.WorkQueue');\ngoog.module.declareLegacyNamespace();\n\nconst FreeList = goog.require('goog.async.FreeList');\nconst {assert} = goog.require('goog.asserts');\n\n// TODO(johnlenz): generalize the WorkQueue if this is used by more\n// than goog.async.run.\n\n\n/**\n * A low GC workqueue. The key elements of this design:\n *   - avoids the need for goog.bind or equivalent by carrying scope\n *   - avoids the need for array reallocation by using a linked list\n *   - minimizes work entry objects allocation by recycling objects\n * @final\n * @struct\n */\nclass WorkQueue {\n  constructor() {\n    this.workHead_ = null;\n    this.workTail_ = null;\n  }\n\n  /**\n   * @param {function()} fn\n   * @param {Object|null|undefined} scope\n   */\n  add(fn, scope) {\n    const item = this.getUnusedItem_();\n    item.set(fn, scope);\n\n    if (this.workTail_) {\n      this.workTail_.next = item;\n      this.workTail_ = item;\n    } else {\n      assert(!this.workHead_);\n      this.workHead_ = item;\n      this.workTail_ = item;\n    }\n  }\n\n  /**\n   * @return {?WorkItem}\n   */\n  remove() {\n    let item = null;\n\n    if (this.workHead_) {\n      item = this.workHead_;\n      this.workHead_ = this.workHead_.next;\n      if (!this.workHead_) {\n        this.workTail_ = null;\n      }\n      item.next = null;\n    }\n    return item;\n  }\n\n  /**\n   * @param {!WorkItem} item\n   */\n  returnUnused(item) {\n    WorkQueue.freelist_.put(item);\n  }\n\n  /**\n   * @return {!WorkItem}\n   * @private\n   */\n  getUnusedItem_() {\n    return WorkQueue.freelist_.get();\n  }\n}\n\n/** @define {number} The maximum number of entries to keep for recycling. */\nWorkQueue.DEFAULT_MAX_UNUSED =\n    goog.define('goog.async.WorkQueue.DEFAULT_MAX_UNUSED', 100);\n\n/** @const @private {!FreeList<!WorkItem>} */\nWorkQueue.freelist_ = new FreeList(\n    () => new WorkItem(), item => item.reset(), WorkQueue.DEFAULT_MAX_UNUSED);\n\n/**\n * @final\n * @struct\n */\nclass WorkItem {\n  constructor() {\n    /** @type {?function()} */\n    this.fn = null;\n    /** @type {?Object|null|undefined} */\n    this.scope = null;\n    /** @type {?WorkItem} */\n    this.next = null;\n  }\n\n  /**\n   * @param {function()} fn\n   * @param {Object|null|undefined} scope\n   */\n  set(fn, scope) {\n    this.fn = fn;\n    this.scope = scope;\n    this.next = null;\n  }\n\n  /** Reset the work item so they don't prevent GC before reuse */\n  reset() {\n    this.fn = null;\n    this.scope = null;\n    this.next = null;\n  }\n}\n\nexports = WorkQueue;\n","~:compiled-at",1728556195039,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.async.workqueue.js\",\n\"lineCount\":66,\n\"mappings\":\"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\",\n\"sources\":[\"goog/async/workqueue.js\"],\n\"sourcesContent\":[\"/**\\n * @license\\n * Copyright The Closure Library Authors.\\n * SPDX-License-Identifier: Apache-2.0\\n */\\n\\ngoog.module('goog.async.WorkQueue');\\ngoog.module.declareLegacyNamespace();\\n\\nconst FreeList = goog.require('goog.async.FreeList');\\nconst {assert} = goog.require('goog.asserts');\\n\\n// TODO(johnlenz): generalize the WorkQueue if this is used by more\\n// than goog.async.run.\\n\\n\\n/**\\n * A low GC workqueue. The key elements of this design:\\n *   - avoids the need for goog.bind or equivalent by carrying scope\\n *   - avoids the need for array reallocation by using a linked list\\n *   - minimizes work entry objects allocation by recycling objects\\n * @final\\n * @struct\\n */\\nclass WorkQueue {\\n  constructor() {\\n    this.workHead_ = null;\\n    this.workTail_ = null;\\n  }\\n\\n  /**\\n   * @param {function()} fn\\n   * @param {Object|null|undefined} scope\\n   */\\n  add(fn, scope) {\\n    const item = this.getUnusedItem_();\\n    item.set(fn, scope);\\n\\n    if (this.workTail_) {\\n      this.workTail_.next = item;\\n      this.workTail_ = item;\\n    } else {\\n      assert(!this.workHead_);\\n      this.workHead_ = item;\\n      this.workTail_ = item;\\n    }\\n  }\\n\\n  /**\\n   * @return {?WorkItem}\\n   */\\n  remove() {\\n    let item = null;\\n\\n    if (this.workHead_) {\\n      item = this.workHead_;\\n      this.workHead_ = this.workHead_.next;\\n      if (!this.workHead_) {\\n        this.workTail_ = null;\\n      }\\n      item.next = null;\\n    }\\n    return item;\\n  }\\n\\n  /**\\n   * @param {!WorkItem} item\\n   */\\n  returnUnused(item) {\\n    WorkQueue.freelist_.put(item);\\n  }\\n\\n  /**\\n   * @return {!WorkItem}\\n   * @private\\n   */\\n  getUnusedItem_() {\\n    return WorkQueue.freelist_.get();\\n  }\\n}\\n\\n/** @define {number} The maximum number of entries to keep for recycling. */\\nWorkQueue.DEFAULT_MAX_UNUSED =\\n    goog.define('goog.async.WorkQueue.DEFAULT_MAX_UNUSED', 100);\\n\\n/** @const @private {!FreeList<!WorkItem>} */\\nWorkQueue.freelist_ = new FreeList(\\n    () => new WorkItem(), item => item.reset(), WorkQueue.DEFAULT_MAX_UNUSED);\\n\\n/**\\n * @final\\n * @struct\\n */\\nclass WorkItem {\\n  constructor() {\\n    /** @type {?function()} */\\n    this.fn = null;\\n    /** @type {?Object|null|undefined} */\\n    this.scope = null;\\n    /** @type {?WorkItem} */\\n    this.next = null;\\n  }\\n\\n  /**\\n   * @param {function()} fn\\n   * @param {Object|null|undefined} scope\\n   */\\n  set(fn, scope) {\\n    this.fn = fn;\\n    this.scope = scope;\\n    this.next = null;\\n  }\\n\\n  /** Reset the work item so they don't prevent GC before reuse */\\n  reset() {\\n    this.fn = null;\\n    this.scope = null;\\n    this.next = null;\\n  }\\n}\\n\\nexports = WorkQueue;\\n\"],\n\"names\":[\"goog\",\"module\",\"declareLegacyNamespace\",\"FreeList\",\"require\",\"assert\",\"WorkQueue\",\"constructor\",\"workHead_\",\"workTail_\",\"add\",\"fn\",\"scope\",\"item\",\"getUnusedItem_\",\"set\",\"next\",\"remove\",\"returnUnused\",\"freelist_\",\"put\",\"get\",\"DEFAULT_MAX_UNUSED\",\"define\",\"WorkItem\",\"reset\",\"exports\"]\n}\n"]